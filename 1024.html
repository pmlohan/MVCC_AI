import React, { useState, useEffect, useCallback } from 'react';
import { Settings, RotateCcw, Trophy, BarChart3, HelpCircle, Volume2, VolumeX, Palette, Zap } from 'lucide-react';

const GRID_SIZE = 4;
const CELL_SIZE = 100;
const CELL_GAP = 10;

const THEMES = {
  classic: {
    name: 'Classic',
    background: 'bg-gray-800',
    board: 'bg-gray-600',
    cell: 'bg-gray-700',
    text: 'text-white'
  },
  ocean: {
    name: 'Ocean',
    background: 'bg-blue-900',
    board: 'bg-blue-700',
    cell: 'bg-blue-600',
    text: 'text-blue-100'
  },
  forest: {
    name: 'Forest',
    background: 'bg-green-900',
    board: 'bg-green-700',
    cell: 'bg-green-600',
    text: 'text-green-100'
  },
  sunset: {
    name: 'Sunset',
    background: 'bg-orange-900',
    board: 'bg-orange-700',
    cell: 'bg-orange-600',
    text: 'text-orange-100'
  }
};

const ACHIEVEMENTS = [
  { id: 'first8', name: 'Getting Started', desc: 'Reach 8', target: 8, icon: 'ðŸŽ¯' },
  { id: 'first16', name: 'Building Up', desc: 'Reach 16', target: 16, icon: 'ðŸ§±' },
  { id: 'first32', name: 'Making Progress', desc: 'Reach 32', target: 32, icon: 'ðŸ“ˆ' },
  { id: 'first64', name: 'Well Done!', desc: 'Reach 64', target: 64, icon: 'âœ¨' },
  { id: 'first128', name: 'Impressive!', desc: 'Reach 128', target: 128, icon: 'ðŸ”¥' },
  { id: 'first256', name: 'Amazing!', desc: 'Reach 256', target: 256, icon: 'ðŸ’Ž' },
  { id: 'first512', name: 'Incredible!', desc: 'Reach 512', target: 512, icon: 'â­' },
  { id: 'first1024', name: 'CHAMPION!', desc: 'Reach 1024!', target: 1024, icon: 'ðŸ‘‘' },
];

const Game1024 = () => {
  // Settings (must be first since other state depends on it)
  const [settings, setSettings] = useState({
    theme: 'classic',
    soundEnabled: true,
    animationsEnabled: true,
    hapticEnabled: true,
    particlesEnabled: true,
    gridSize: 4
  });

  // Core game state
  const [score, setScore] = useState(0);
  const [bestScore, setBestScore] = useState(0);
  const [gameWon, setGameWon] = useState(false);
  const [gameOver, setGameOver] = useState(false);
  const [isAnimating, setIsAnimating] = useState(false);
  
  // History for undo
  const [gameHistory, setGameHistory] = useState([]);
  const [canUndo, setCanUndo] = useState(false);
  
  // UI state
  const [showSettings, setShowSettings] = useState(false);
  const [showStats, setShowStats] = useState(false);
  const [showTutorial, setShowTutorial] = useState(false);
  const [showAchievements, setShowAchievements] = useState(false);
  const [newAchievement, setNewAchievement] = useState(null);
  
  // Statistics
  const [stats, setStats] = useState({
    gamesPlayed: 0,
    gamesWon: 0,
    totalScore: 0,
    bestMove: 0,
    achievements: []
  });

  // Initialize board after settings
  const [board, setBoard] = useState(() => {
    const gridSize = 4; // Default grid size for initialization
    const newBoard = Array(gridSize).fill().map(() => Array(gridSize).fill(0));
    // Add initial tiles manually to avoid dependency issues
    const emptyCells = [];
    for (let i = 0; i < gridSize; i++) {
      for (let j = 0; j < gridSize; j++) {
        emptyCells.push([i, j]);
      }
    }
    // Add two random tiles
    for (let k = 0; k < 2; k++) {
      if (emptyCells.length > 0) {
        const randomIndex = Math.floor(Math.random() * emptyCells.length);
        const [row, col] = emptyCells[randomIndex];
        newBoard[row][col] = Math.random() < 0.9 ? 2 : 4;
        emptyCells.splice(randomIndex, 1);
      }
    }
    return newBoard;
  });
  
  // Touch/animation state
  const [touchStart, setTouchStart] = useState(null);
  const [touchEnd, setTouchEnd] = useState(null);
  const [isDragging, setIsDragging] = useState(false);
  const [swipeDirection, setSwipeDirection] = useState(null);
  const [dragOffset, setDragOffset] = useState({ x: 0, y: 0 });
  const [particles, setParticles] = useState([]);
  const [mergingTiles, setMergingTiles] = useState([]);
  const [newTiles, setNewTiles] = useState([]);

  const theme = THEMES[settings.theme];
  const minSwipeDistance = 20;
  const previewThreshold = 15;
  const maxDragDistance = 30;

  function initializeBoard(gridSize = settings.gridSize) {
    const newBoard = Array(gridSize).fill().map(() => Array(gridSize).fill(0));
    addRandomTile(newBoard, gridSize);
    addRandomTile(newBoard, gridSize);
    return newBoard;
  }

  function addRandomTile(board, gridSize = settings.gridSize) {
    if (!board || !Array.isArray(board)) return;
    
    const emptyCells = [];
    for (let i = 0; i < gridSize; i++) {
      for (let j = 0; j < gridSize; j++) {
        if (board[i] && board[i][j] === 0) {
          emptyCells.push([i, j]);
        }
      }
    }
    
    if (emptyCells.length > 0) {
      const [row, col] = emptyCells[Math.floor(Math.random() * emptyCells.length)];
      const maxTile = Math.max(...board.flat().filter(val => val !== undefined && val !== null));
      const randomValue = Math.random();
      
      let newTileValue = 2;
      
      if (maxTile <= 8) {
        newTileValue = randomValue < 0.9 ? 2 : 4;
      } else if (maxTile <= 32) {
        if (randomValue < 0.85) newTileValue = 2;
        else if (randomValue < 0.99) newTileValue = 4;
        else newTileValue = 8;
      } else if (maxTile <= 128) {
        if (randomValue < 0.80) newTileValue = 2;
        else if (randomValue < 0.95) newTileValue = 4;
        else if (randomValue < 0.99) newTileValue = 8;
        else newTileValue = 16;
      } else if (maxTile <= 512) {
        if (randomValue < 0.75) newTileValue = 2;
        else if (randomValue < 0.93) newTileValue = 4;
        else if (randomValue < 0.98) newTileValue = 8;
        else if (randomValue < 0.995) newTileValue = 16;
        else newTileValue = 32;
      } else {
        if (randomValue < 0.70) newTileValue = 2;
        else if (randomValue < 0.90) newTileValue = 4;
        else if (randomValue < 0.97) newTileValue = 8;
        else if (randomValue < 0.99) newTileValue = 16;
        else if (randomValue < 0.998) newTileValue = 32;
        else newTileValue = 64;
      }
      
      if (board[row] && board[row][col] !== undefined) {
        board[row][col] = newTileValue;
        
        // Add to new tiles for animation
        if (settings.animationsEnabled) {
          setNewTiles(prev => [...prev, { row, col, value: newTileValue, id: Date.now() + Math.random() }]);
          setTimeout(() => {
            setNewTiles(prev => prev.filter(tile => tile.row !== row || tile.col !== col));
          }, 300);
        }
      }
    }
  }

  function saveGameState() {
    const state = {
      board: board.map(row => [...row]),
      score,
      gameWon,
      gameOver
    };
    setGameHistory(prev => [...prev.slice(-9), state]); // Keep last 10 states
    setCanUndo(true);
  }

  function undoMove() {
    if (gameHistory.length === 0 || isAnimating) return;
    
    const previousState = gameHistory[gameHistory.length - 1];
    setBoard(previousState.board);
    setScore(previousState.score);
    setGameWon(previousState.gameWon);
    setGameOver(previousState.gameOver);
    setGameHistory(prev => prev.slice(0, -1));
    setCanUndo(gameHistory.length > 1);
    
    playSound('undo');
    vibrate();
  }

  function moveLeft(board) {
    let moved = false;
    let scoreGained = 0;
    let mergeCount = 0;
    const newBoard = board.map(row => [...row]);
    const gridSize = board.length; // Use board's actual size

    for (let i = 0; i < gridSize; i++) {
      const row = newBoard[i].filter(cell => cell !== 0);
      for (let j = 0; j < row.length - 1; j++) {
        if (row[j] === row[j + 1]) {
          row[j] *= 2;
          scoreGained += row[j];
          mergeCount++;
          
          // Add merge animation
          if (settings.animationsEnabled) {
            setMergingTiles(prev => [...prev, { row: i, col: j, value: row[j], id: Date.now() + Math.random() }]);
          }
          
          // Create particles
          if (settings.particlesEnabled) {
            createParticles(i, j, row[j]);
          }
          
          // Check achievements
          checkAchievement(row[j]);
          
          if (row[j] === 1024 && !gameWon) {
            setGameWon(true);
            playSound('win');
            checkAchievement(1024);
          }
          
          row[j + 1] = 0;
          j++;
        }
      }
      const newRow = row.filter(cell => cell !== 0);
      while (newRow.length < gridSize) {
        newRow.push(0);
      }
      
      for (let j = 0; j < gridSize; j++) {
        if (newBoard[i][j] !== newRow[j]) {
          moved = true;
        }
        newBoard[i][j] = newRow[j];
      }
    }

    // Combo bonus
    if (mergeCount > 1) {
      const comboBonus = mergeCount * 50;
      scoreGained += comboBonus;
      showComboEffect(mergeCount);
    }

    return { board: newBoard, moved, scoreGained };
  }

  function createParticles(row, col, value) {
    const colors = ['#fbbf24', '#f59e0b', '#d97706', '#92400e'];
    const newParticles = [];
    
    for (let i = 0; i < 6; i++) {
      newParticles.push({
        id: Date.now() + Math.random(),
        x: col * (CELL_SIZE + CELL_GAP) + CELL_GAP + CELL_SIZE / 2,
        y: row * (CELL_SIZE + CELL_GAP) + CELL_GAP + CELL_SIZE / 2,
        vx: (Math.random() - 0.5) * 100,
        vy: (Math.random() - 0.5) * 100,
        color: colors[Math.floor(Math.random() * colors.length)],
        life: 1,
        decay: 0.02
      });
    }
    
    setParticles(prev => [...prev, ...newParticles]);
    
    setTimeout(() => {
      setParticles(prev => prev.filter(p => !newParticles.includes(p)));
    }, 1000);
  }

  function showComboEffect(count) {
    // Add visual combo effect
    const comboElement = document.createElement('div');
    comboElement.textContent = `${count}x COMBO!`;
    comboElement.className = 'fixed top-1/2 left-1/2 transform -translate-x-1/2 -translate-y-1/2 text-4xl font-bold text-yellow-400 pointer-events-none z-50 animate-bounce';
    document.body.appendChild(comboElement);
    
    setTimeout(() => {
      if (document.body.contains(comboElement)) {
        document.body.removeChild(comboElement);
      }
    }, 1500);
  }

  function checkAchievement(value) {
    const achievement = ACHIEVEMENTS.find(a => a.target === value && !stats.achievements.includes(a.id));
    if (achievement) {
      setStats(prev => ({
        ...prev,
        achievements: [...prev.achievements, achievement.id]
      }));
      setNewAchievement(achievement);
      playSound('achievement');
      setTimeout(() => setNewAchievement(null), 3000);
    }
  }

  function playSound(type) {
    if (!settings.soundEnabled) return;
    
    // Create audio context and play different tones for different actions
    const audioContext = new (window.AudioContext || window.webkitAudioContext)();
    const oscillator = audioContext.createOscillator();
    const gainNode = audioContext.createGain();
    
    oscillator.connect(gainNode);
    gainNode.connect(audioContext.destination);
    
    const frequencies = {
      move: 220,
      merge: 440,
      win: 880,
      achievement: 660,
      undo: 330
    };
    
    oscillator.frequency.setValueAtTime(frequencies[type] || 220, audioContext.currentTime);
    oscillator.type = 'sine';
    
    gainNode.gain.setValueAtTime(0.1, audioContext.currentTime);
    gainNode.gain.exponentialRampToValueAtTime(0.01, audioContext.currentTime + 0.1);
    
    oscillator.start(audioContext.currentTime);
    oscillator.stop(audioContext.currentTime + 0.1);
  }

  function vibrate() {
    if (!settings.hapticEnabled || !navigator.vibrate) return;
    navigator.vibrate(50);
  }

  function rotateBoard(board) {
    const gridSize = board.length; // Use board's actual size
    const newBoard = Array(gridSize).fill().map(() => Array(gridSize).fill(0));
    for (let i = 0; i < gridSize; i++) {
      for (let j = 0; j < gridSize; j++) {
        newBoard[j][gridSize - 1 - i] = board[i][j];
      }
    }
    return newBoard;
  }

  function move(direction) {
    if (gameOver || isAnimating) return;

    saveGameState();
    setIsAnimating(true);

    let currentBoard = [...board.map(row => [...row])];
    let rotations = 0;

    switch (direction) {
      case 'up': rotations = 3; break;
      case 'right': rotations = 2; break;
      case 'down': rotations = 1; break;
      default: rotations = 0;
    }

    for (let i = 0; i < rotations; i++) {
      currentBoard = rotateBoard(currentBoard);
    }

    const { board: movedBoard, moved, scoreGained } = moveLeft(currentBoard);

    let finalBoard = movedBoard;
    for (let i = 0; i < (4 - rotations) % 4; i++) {
      finalBoard = rotateBoard(finalBoard);
    }

    if (moved) {
      setBoard([...finalBoard.map(row => [...row])]);
      setScore(prev => {
        const newScore = prev + scoreGained;
        if (newScore > bestScore) setBestScore(newScore);
        return newScore;
      });
      
      playSound('move');
      if (scoreGained > 0) playSound('merge');
      vibrate();

      setTimeout(() => {
        const boardWithNewTile = [...finalBoard.map(row => [...row])];
        addRandomTile(boardWithNewTile, boardWithNewTile.length);
        setBoard(boardWithNewTile);
        setIsAnimating(false);
        
        if (!canMove(boardWithNewTile)) {
          setGameOver(true);
          setStats(prev => ({
            ...prev,
            gamesPlayed: prev.gamesPlayed + 1,
            totalScore: prev.totalScore + score,
            bestMove: Math.max(prev.bestMove, scoreGained)
          }));
        }
      }, settings.animationsEnabled ? 500 : 0);
    } else {
      setIsAnimating(false);
    }
  }

  function canMove(board) {
    const gridSize = board.length; // Use board's actual size
    
    for (let i = 0; i < gridSize; i++) {
      for (let j = 0; j < gridSize; j++) {
        if (board[i][j] === 0) return true;
      }
    }

    for (let i = 0; i < gridSize; i++) {
      for (let j = 0; j < gridSize; j++) {
        const current = board[i][j];
        if (
          (i < gridSize - 1 && board[i + 1][j] === current) ||
          (j < gridSize - 1 && board[i][j + 1] === current)
        ) {
          return true;
        }
      }
    }
    return false;
  }

  // Touch handlers
  const onTouchStart = (e) => {
    e.preventDefault();
    if (isAnimating) return;
    
    setTouchEnd(null);
    setIsDragging(true);
    setSwipeDirection(null);
    setDragOffset({ x: 0, y: 0 });
    setTouchStart({
      x: e.targetTouches[0].clientX,
      y: e.targetTouches[0].clientY
    });
  };

  const onTouchMove = (e) => {
    e.preventDefault();
    if (!touchStart || isAnimating) return;

    const currentTouch = {
      x: e.targetTouches[0].clientX,
      y: e.targetTouches[0].clientY
    };

    setTouchEnd(currentTouch);

    const distanceX = touchStart.x - currentTouch.x;
    const distanceY = touchStart.y - currentTouch.y;
    const absDistanceX = Math.abs(distanceX);
    const absDistanceY = Math.abs(distanceY);

    let offsetX = 0;
    let offsetY = 0;

    if (absDistanceX > absDistanceY && absDistanceX > previewThreshold) {
      const direction = distanceX > 0 ? 'left' : 'right';
      setSwipeDirection(direction);
      offsetX = Math.max(-maxDragDistance, Math.min(maxDragDistance, -distanceX));
    } else if (absDistanceY > previewThreshold) {
      const direction = distanceY > 0 ? 'up' : 'down';
      setSwipeDirection(direction);
      offsetY = Math.max(-maxDragDistance, Math.min(maxDragDistance, -distanceY));
    }

    setDragOffset({ x: offsetX, y: offsetY });
  };

  const onTouchEnd = (e) => {
    e.preventDefault();
    setIsDragging(false);
    setSwipeDirection(null);
    
    setTimeout(() => setDragOffset({ x: 0, y: 0 }), 50);

    if (!touchStart || !touchEnd || isAnimating) return;
    
    const distanceX = touchStart.x - touchEnd.x;
    const distanceY = touchStart.y - touchEnd.y;
    const absDistanceX = Math.abs(distanceX);
    const absDistanceY = Math.abs(distanceY);

    if (absDistanceX > minSwipeDistance || absDistanceY > minSwipeDistance) {
      if (absDistanceX > absDistanceY) {
        move(distanceX > 0 ? 'left' : 'right');
      } else {
        move(distanceY > 0 ? 'up' : 'down');
      }
    }
  };

  const handleKeyPress = useCallback((e) => {
    if (isAnimating || showSettings || showStats || showTutorial) return;
    
    switch (e.key) {
      case 'ArrowLeft': e.preventDefault(); move('left'); break;
      case 'ArrowRight': e.preventDefault(); move('right'); break;
      case 'ArrowUp': e.preventDefault(); move('up'); break;
      case 'ArrowDown': e.preventDefault(); move('down'); break;
      case 'u': case 'U': e.preventDefault(); undoMove(); break;
      case 'r': case 'R': e.preventDefault(); resetGame(); break;
    }
  }, [isAnimating, showSettings, showStats, showTutorial]);

  useEffect(() => {
    window.addEventListener('keydown', handleKeyPress);
    return () => window.removeEventListener('keydown', handleKeyPress);
  }, [handleKeyPress]);

  function resetGame() {
    setIsAnimating(true);
    setIsDragging(false);
    setSwipeDirection(null);
    setDragOffset({ x: 0, y: 0 });
    setTouchStart(null);
    setTouchEnd(null);
    setGameHistory([]);
    setCanUndo(false);
    setParticles([]);
    setMergingTiles([]);
    setNewTiles([]);
    
    const newBoard = initializeBoard(settings.gridSize);
    setBoard(newBoard);
    setScore(0);
    setGameWon(false);
    setGameOver(false);
    
    setTimeout(() => setIsAnimating(false), 100);
  }

  const getTileColor = (value) => {
    const colors = {
      2: 'bg-gray-100 text-gray-800',
      4: 'bg-gray-200 text-gray-800',
      8: 'bg-orange-200 text-orange-800',
      16: 'bg-orange-300 text-orange-800',
      32: 'bg-orange-400 text-white',
      64: 'bg-orange-500 text-white',
      128: 'bg-yellow-400 text-white',
      256: 'bg-yellow-500 text-white',
      512: 'bg-yellow-600 text-white',
      1024: 'bg-yellow-700 text-white animate-pulse',
      2048: 'bg-red-500 text-white animate-pulse',
      4096: 'bg-red-600 text-white animate-pulse',
    };
    return colors[value] || 'bg-purple-500 text-white animate-pulse';
  };

  const SettingsPanel = () => (
    <div className="fixed inset-0 bg-black bg-opacity-50 flex items-center justify-center z-50">
      <div className={`${theme.background} ${theme.text} rounded-lg p-6 max-w-md w-full mx-4 max-h-screen overflow-y-auto`}>
        <div className="flex justify-between items-center mb-4">
          <h2 className="text-2xl font-bold">Settings</h2>
          <button onClick={() => setShowSettings(false)} className="text-2xl">Ã—</button>
        </div>
        
        <div className="space-y-4">
          <div>
            <label className="block text-sm font-medium mb-2">Theme</label>
            <select 
              value={settings.theme} 
              onChange={(e) => setSettings(prev => ({...prev, theme: e.target.value}))}
              className="w-full p-2 rounded bg-gray-700 text-white"
            >
              {Object.entries(THEMES).map(([key, theme]) => (
                <option key={key} value={key}>{theme.name}</option>
              ))}
            </select>
          </div>
          
          <div className="space-y-2">
            {[
              { key: 'soundEnabled', label: 'Sound Effects', icon: settings.soundEnabled ? Volume2 : VolumeX },
              { key: 'animationsEnabled', label: 'Animations', icon: Zap },
              { key: 'hapticEnabled', label: 'Haptic Feedback', icon: Zap },
              { key: 'particlesEnabled', label: 'Particle Effects', icon: Zap }
            ].map(({ key, label, icon: Icon }) => (
              <div key={key} className="flex items-center justify-between">
                <div className="flex items-center space-x-2">
                  <Icon size={16} />
                  <span>{label}</span>
                </div>
                <button
                  onClick={() => setSettings(prev => ({...prev, [key]: !prev[key]}))}
                  className={`w-12 h-6 rounded-full relative transition-colors ${
                    settings[key] ? 'bg-green-500' : 'bg-gray-600'
                  }`}
                >
                  <div className={`w-5 h-5 bg-white rounded-full absolute top-0.5 transition-transform ${
                    settings[key] ? 'translate-x-6' : 'translate-x-0.5'
                  }`} />
                </button>
              </div>
            ))}
          </div>
        </div>
      </div>
    </div>
  );

  const StatsPanel = () => (
    <div className="fixed inset-0 bg-black bg-opacity-50 flex items-center justify-center z-50">
      <div className={`${theme.background} ${theme.text} rounded-lg p-6 max-w-md w-full mx-4`}>
        <div className="flex justify-between items-center mb-4">
          <h2 className="text-2xl font-bold">Statistics</h2>
          <button onClick={() => setShowStats(false)} className="text-2xl">Ã—</button>
        </div>
        
        <div className="space-y-3">
          <div className="flex justify-between">
            <span>Games Played:</span>
            <span className="font-bold">{stats.gamesPlayed}</span>
          </div>
          <div className="flex justify-between">
            <span>Win Rate:</span>
            <span className="font-bold">
              {stats.gamesPlayed > 0 ? Math.round((stats.gamesWon / stats.gamesPlayed) * 100) : 0}%
            </span>
          </div>
          <div className="flex justify-between">
            <span>Best Score:</span>
            <span className="font-bold">{bestScore}</span>
          </div>
          <div className="flex justify-between">
            <span>Average Score:</span>
            <span className="font-bold">
              {stats.gamesPlayed > 0 ? Math.round(stats.totalScore / stats.gamesPlayed) : 0}
            </span>
          </div>
          <div className="flex justify-between">
            <span>Best Single Move:</span>
            <span className="font-bold">{stats.bestMove}</span>
          </div>
          <div className="flex justify-between">
            <span>Achievements:</span>
            <span className="font-bold">{stats.achievements.length}/{ACHIEVEMENTS.length}</span>
          </div>
        </div>
      </div>
    </div>
  );

  const AchievementsPanel = () => (
    <div className="fixed inset-0 bg-black bg-opacity-50 flex items-center justify-center z-50">
      <div className={`${theme.background} ${theme.text} rounded-lg p-6 max-w-md w-full mx-4 max-h-screen overflow-y-auto`}>
        <div className="flex justify-between items-center mb-4">
          <h2 className="text-2xl font-bold">Achievements</h2>
          <button onClick={() => setShowAchievements(false)} className="text-2xl">Ã—</button>
        </div>
        
        <div className="space-y-3">
          {ACHIEVEMENTS.map(achievement => {
            const unlocked = stats.achievements.includes(achievement.id);
            return (
              <div key={achievement.id} className={`p-3 rounded ${unlocked ? 'bg-green-600' : 'bg-gray-600'} ${unlocked ? 'opacity-100' : 'opacity-50'}`}>
                <div className="flex items-center space-x-3">
                  <span className="text-2xl">{achievement.icon}</span>
                  <div>
                    <div className="font-bold">{achievement.name}</div>
                    <div className="text-sm">{achievement.desc}</div>
                  </div>
                </div>
              </div>
            );
          })}
        </div>
      </div>
    </div>
  );

  const TutorialPanel = () => (
    <div className="fixed inset-0 bg-black bg-opacity-50 flex items-center justify-center z-50">
      <div className={`${theme.background} ${theme.text} rounded-lg p-6 max-w-md w-full mx-4`}>
        <div className="flex justify-between items-center mb-4">
          <h2 className="text-2xl font-bold">How to Play</h2>
          <button onClick={() => setShowTutorial(false)} className="text-2xl">Ã—</button>
        </div>
        
        <div className="space-y-4 text-sm">
          <div>
            <h3 className="font-bold mb-1">ðŸŽ¯ Goal</h3>
            <p>Combine tiles with the same number to reach 1024!</p>
          </div>
          
          <div>
            <h3 className="font-bold mb-1">ðŸŽ® Controls</h3>
            <p>â€¢ Swipe or use arrow keys to move tiles<br/>
            â€¢ Press U to undo your last move<br/>
            â€¢ Press R to restart the game</p>
          </div>
          
          <div>
            <h3 className="font-bold mb-1">âœ¨ Features</h3>
            <p>â€¢ Earn achievements for reaching milestones<br/>
            â€¢ Get combo bonuses for multiple merges<br/>
            â€¢ Track your progress in statistics<br/>
            â€¢ Customize your experience in settings</p>
          </div>
        </div>
      </div>
    </div>
  );

  return (
    <div className={`flex flex-col items-center justify-center min-h-screen ${theme.background} ${theme.text} p-4 relative overflow-hidden`}>
      {/* Particles */}
      {settings.particlesEnabled && particles.map(particle => (
        <div
          key={particle.id}
          className="absolute w-2 h-2 rounded-full pointer-events-none z-10"
          style={{
            left: particle.x,
            top: particle.y,
            backgroundColor: particle.color,
            opacity: particle.life,
            transform: `translate(${particle.vx}px, ${particle.vy}px)`
          }}
        />
      ))}

      {/* Achievement Notification */}
      {newAchievement && (
        <div className="fixed top-4 left-1/2 transform -translate-x-1/2 bg-green-600 text-white p-4 rounded-lg shadow-lg z-50 animate-bounce">
          <div className="flex items-center space-x-2">
            <span className="text-2xl">{newAchievement.icon}</span>
            <div>
              <div className="font-bold">Achievement Unlocked!</div>
              <div className="text-sm">{newAchievement.name}</div>
            </div>
          </div>
        </div>
      )}

      {/* Header */}
      <div className="mb-6 text-center w-full max-w-lg">
        <div className="flex justify-between items-center mb-4">
          <button onClick={() => setShowTutorial(true)} className="p-2 rounded hover:bg-gray-700">
            <HelpCircle size={24} />
          </button>
          <h1 className="text-4xl font-bold">1024</h1>
          <button onClick={() => setShowSettings(true)} className="p-2 rounded hover:bg-gray-700">
            <Settings size={24} />
          </button>
        </div>

        <div className="flex justify-between items-center mb-4">
          <div className="text-center">
            <div className="text-lg font-bold">{score}</div>
            <div className="text-sm text-gray-400">Score</div>
          </div>
          <div className="text-center">
            <div className="text-lg font-bold">{bestScore}</div>
            <div className="text-sm text-gray-400">Best</div>
          </div>
        </div>

        <div className="flex justify-center space-x-2 mb-4">
          <button 
            onClick={undoMove} 
            disabled={!canUndo || isAnimating}
            className="flex items-center space-x-1 px-3 py-2 bg-blue-600 hover:bg-blue-700 disabled:bg-gray-600 disabled:cursor-not-allowed rounded-lg transition-colors"
          >
            <RotateCcw size={16} />
            <span>Undo</span>
          </button>
          <button onClick={() => setShowStats(true)} className="flex items-center space-x-1 px-3 py-2 bg-purple-600 hover:bg-purple-700 rounded-lg transition-colors">
            <BarChart3 size={16} />
            <span>Stats</span>
          </button>
          <button onClick={() => setShowAchievements(true)} className="flex items-center space-x-1 px-3 py-2 bg-yellow-600 hover:bg-yellow-700 rounded-lg transition-colors">
            <Trophy size={16} />
            <span>Awards</span>
          </button>
          <button onClick={resetGame} className="px-3 py-2 bg-green-600 hover:bg-green-700 rounded-lg transition-colors">
            New Game
          </button>
        </div>
      </div>

      {/* Game Board */}
      <div 
        className={`relative ${theme.board} rounded-lg p-2 touch-none select-none transition-all duration-100 ${
          isDragging ? 'scale-[1.02] shadow-lg' : ''
        } ${
          swipeDirection === 'left' ? 'border-l-4 border-blue-400' :
          swipeDirection === 'right' ? 'border-r-4 border-blue-400' :
          swipeDirection === 'up' ? 'border-t-4 border-blue-400' :
          swipeDirection === 'down' ? 'border-b-4 border-blue-400' : ''
        }`}
        style={{
          width: board.length * CELL_SIZE + (board.length + 1) * CELL_GAP,
          height: board.length * CELL_SIZE + (board.length + 1) * CELL_GAP,
        }}
        onTouchStart={onTouchStart}
        onTouchMove={onTouchMove}
        onTouchEnd={onTouchEnd}
      >
        {/* Grid background */}
        {Array(board.length).fill().map((_, i) =>
          Array(board.length).fill().map((_, j) => (
            <div
              key={`bg-${i}-${j}`}
              className={`absolute rounded transition-colors duration-100 ${
                isDragging ? theme.cell : theme.cell
              }`}
              style={{
                left: j * (CELL_SIZE + CELL_GAP) + CELL_GAP,
                top: i * (CELL_SIZE + CELL_GAP) + CELL_GAP,
                width: CELL_SIZE,
                height: CELL_SIZE,
              }}
            />
          ))
        )}

        {/* Tiles */}
        {board.map((row, i) =>
          row.map((value, j) => {
            if (value === 0) return null;
            
            const isNewTile = newTiles.some(tile => tile.row === i && tile.col === j);
            const isMerging = mergingTiles.some(tile => tile.row === i && tile.col === j);
            
            const tileStyle = {
              left: j * (CELL_SIZE + CELL_GAP) + CELL_GAP,
              top: i * (CELL_SIZE + CELL_GAP) + CELL_GAP,
              width: CELL_SIZE,
              height: CELL_SIZE,
              fontSize: value >= 100 ? '18px' : '22px',
              zIndex: 10,
              transform: isDragging 
                ? `translate(${dragOffset.x}px, ${dragOffset.y}px) ${isNewTile ? 'scale(0)' : ''} ${isMerging ? 'scale(1.1)' : ''}` 
                : `translate(0, 0) ${isNewTile ? 'scale(1)' : ''} ${isMerging ? 'scale(1)' : ''}`,
              transition: isDragging 
                ? (isNewTile ? 'transform 0.3s ease-out' : 'none')
                : (settings.animationsEnabled ? 'all 0.5s cubic-bezier(0.175, 0.885, 0.32, 1.275), transform 0.5s cubic-bezier(0.175, 0.885, 0.32, 1.275)' : 'none'),
            };

            return (
              <div
                key={`${i}-${j}`}
                className={`absolute rounded font-bold flex items-center justify-center ${getTileColor(value)} ${
                  isDragging ? 'shadow-2xl scale-105' : ''
                } ${isAnimating ? 'shadow-lg' : ''} ${isNewTile ? 'animate-bounce' : ''} ${isMerging ? 'animate-pulse' : ''}`}
                style={tileStyle}
              >
                {value}
              </div>
            );
          })
        )}
      </div>

      {/* Game status messages */}
      {gameWon && (
        <div className="fixed inset-0 bg-black bg-opacity-50 flex items-center justify-center z-40">
          <div className="bg-green-600 rounded-lg p-8 text-center text-white">
            <h2 className="text-4xl font-bold mb-2">ðŸŽ‰ You Win!</h2>
            <p className="text-xl mb-4">You reached 1024!</p>
            <button onClick={() => setGameWon(false)} className="px-6 py-2 bg-white text-green-600 rounded-lg font-bold">
              Continue Playing
            </button>
          </div>
        </div>
      )}

      {gameOver && (
        <div className="fixed inset-0 bg-black bg-opacity-50 flex items-center justify-center z-40">
          <div className="bg-red-600 rounded-lg p-8 text-center text-white">
            <h2 className="text-4xl font-bold mb-2">Game Over!</h2>
            <p className="text-xl mb-2">Final Score: {score}</p>
            <p className="text-lg mb-4">No more moves available.</p>
            <button onClick={resetGame} className="px-6 py-2 bg-white text-red-600 rounded-lg font-bold">
              Try Again
            </button>
          </div>
        </div>
      )}

      {/* Panels */}
      {showSettings && <SettingsPanel />}
      {showStats && <StatsPanel />}
      {showAchievements && <AchievementsPanel />}
      {showTutorial && <TutorialPanel />}

      {/* Mobile instructions */}
      <div className="mt-4 text-center text-sm text-gray-400 max-w-lg">
        <p>Swipe to move tiles â€¢ Combine same numbers to reach 1024!</p>
        <p className="text-xs mt-1">Press U to undo â€¢ R to restart â€¢ Click icons for more options</p>
      </div>
    </div>
  );
};

export default Game1024;
